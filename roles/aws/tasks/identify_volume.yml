# at this point this should probably be a custom module...
- name: Find the device mounted at {{ mount_point }}
  ansible.builtin.set_fact:
    # Find the mount, get the first result, and extract its 'device' attribute
    partition_device: "{{ (ansible_facts.mounts | selectattr('mount', 'equalto', mount_point) | list | first | default({})).device | trim }}"
  when: ansible_facts.mounts is defined

- name: "Fail if the mount point '{{ mount_point }}' was not found"
  ansible.builtin.fail:
    msg: "The specified mount point was not found on the system."
  when: partition_device is not defined or partition_device is none

- name: "Find the parent device for '{{ partition_device }}' using lsblk"
  ansible.builtin.shell: "lsblk -no pkname {{ partition_device }}"
  register: pkname_result
  changed_when: false
  failed_when: false # Don't fail if the device is not a partition

- name: Determine the final root block device
  ansible.builtin.set_fact:
    # If lsblk found a parent name, use it. Otherwise, use the original device.
    root_block_device: "{{ (pkname_result.stdout | trim != '') | ternary('/dev/' ~ (pkname_result.stdout | trim), partition_device) }}"

- name: 4. Get serial number (volume ID) for {{ root_block_device }}
  ansible.builtin.shell: "lsblk -o SERIAL -n -d {{ root_block_device }}"
  # ansible.builtin.shell: "lsblk -o SERIAL -n -d {{ source_device_disk }}"
  register: source_device_serial
  # # Loop through all found mounts and ignore temporary/virtual filesystems
  # loop: "{{ ansible_facts.mount_points | selectattr('fstype', 'not in', ['tmpfs', 'devtmpfs', 'nfs4', 'overlay']) | list }}"
  changed_when: false
  # failed_when: lsblk_result.rc > 1 # lsblk returns 1 if device not found, which is ok for some mounts

- name: Transform the volumeID to something AWS will likely accept 
  ansible.builtin.set_fact:
    aws_volume_id: "{{ source_device_serial.stdout[:3] ~ '-' ~ source_device_serial.stdout[3:] }}"
